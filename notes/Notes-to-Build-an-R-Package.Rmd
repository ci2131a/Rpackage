---
title: "How to Build an R Package"
author: "Charles Ingulli"
date: "`r format(Sys.time(), '%B %d, %Y')`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE,
                      eval = FALSE)
```

# Introduction

This document contains some notes for creating an R package. All information has been collected through the process of making my first R package.


## Setup


# Package Deveklopment

## R Code

## Data

If you are planning to include data in your R package, continue reading this section. If not, feel free to move on to the next section.


When including data in your R package that is to be available to users, it is most likely to be stored in the `data/` folder as a `.rda` file. Each file will contain a singular R object such as a data frame or tibble. 
<!--For example, you may have `data/survival_data.rda` as a package data set to be called through `Rpackage::survival_data` when loaded. -->
To save your data sets to this folder in the format, the `usethis::use_data(Robject)` function will take an existing object from your environment and compress it to the `.rda` format for inclusion in your package. This function should add `LazyData: true` to the `DESCRIPTION` file (you should double check that this is in there). The selected option will ensure data only uses memory when you want to use it. 

Note: I should check if the LazyData option comes up anywhere else.

The `use_data()` function defaults to a "bzip2" compression of data. There also exist "gzip" and "xy" compression which may result in smaller data sizes. It is important to find the best compression option for your data as CRAN has limits on the size. Apparently, there are cases to be made if you have large data and your package is to make data available. It helps if that data will then not be updated often. The general rule seems to be that data should not be larger that 1MB. I am not sure if this is all data sets or each individual data set.

Details on how to evaluate the compression should be here.

Keeping the map to data set creation is important. The final data set creation script should include the compression option chosen.


### Internal Data


## Documentation

# Old Notes

The first step to making an R package is setting up our working environment to add all the necessary components. We describe the setup here.

### Requirements

#### as List

* *_Programs_*
  - R (>= 3.1.2)
  - RStudio
  - Rtools
* *_Packages_*
  - `devtools`
  - `roxygen2`
  - `testthat`
  - `knitr`

#### as Description 

An R installation is required of version 3.1.2 or greater. We are going to require RStudio for its usefulness. Any recent version should work. RStudio is a great IDE with many benefits for novices and experts. This is not a technical requirement and it possible to create an R package without RStudio, but it is not recommended. 


After R is installed, there are a few R packages that are needed before we can build our package. These include: `devtools`, `roxygen2`, `testthat`, and `knitr`. `devtools` provides a lot of R functions that will allow you to interact with packages. For example, you can install them, bundle them, add licenses, and more just with a few simple functions. `roxygen2` is used for something. I believe `testthat` is 


If you do not have these packages install them through the `install.packages()` function. If you are unsure whether or not you have these packages, (I was at first) try the following code to check if you have the packages installed and if not install them:

```{r}
# check for installed package; if missing will install
for (package in c("devtools", "roxygen2", "testthat", "knitr")){
  if(package %in% rownames(installed.packages()) == FALSE) {
    install.packages(package)
  } else {
    #print(paste0(package," is installed"))
    cat(package,"version",packageVersion(package), "is already installed.\n")
  }
}

```


If you are using RStudio, you can look at the list of packages under the tab *Packages*.
Additionally, to compile packages from source, we need Rtools.


## Create Necessary Files

### R Project

RStudio provides a helpful tool to create all the necessary R package files in one directory called a Project. R's Project is useful for switching between tasks and files within RStudio. It remembers the files that were open, can be used for version history, and can load the environment with previous `.RData` files.
For more information, see RStudio Support's article on [Projects](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects) and check out the related articles.


We are interested in packages and there exists a specific subclass of Project specifically for this. It will at the very least create all the necessary files for an R package but at most has all the functionality described earlier. 
In RStudio, navigate to *File* > *New Project...* in order to create a new R project. We will use the R project to hold all the files, environments, and history relating to the package. When creating your package from scratch, select a new directory in which to place all files. 


The workflow will follow by:
1. navigate to *File* > *New Project...*
2. select new directory
3. Choose R Package
4. Name your package (this is the hardest part)
5. Select the desired directory


This will create a new directory with the same name as your package include fill it with many of the necessary components to build a package. Such components include another directory called R to hold all .R files, a file called DESCRIPTION which will describe what your package does, a file called NAMESPACE to note any interactions with other packages, a .Rproj file which will maintain the project environment created by RStudio, and a .Rbuildignore file that will ignore any files contained within it if you decide to bundle your package. Also creates the man folder

## Some R code!

The bulk of the package will consist of various `.R` files (scripts) that define functions to use. 
Organize the functions however you want. R does a lazy load of all files when you run a package. Effectively, it means that R does not check to see if all objects exist when it runs the files. So, if you define a function that calls another function thats defined somewhere else, R will process both functions and look to find it only when you execute the function.

### Some best practices

Use `<-` for assignment rather than `=` in R.


Try to organize functions in appropriate R files. Avoid placing each function in its own file; it is okay for more complex functions. Use good judgement.



Do not use source or library in your R files. The source is used to run all the code within a particular file but when you build your package R inherently does this so you should not use source as it will adversely affect the environment. Also, you should not use library because this function requires that a package already be installed. If someone using your package does not have the package you are trying to access with library then there will be issues. Instead, list these required functions in your namespace so they will be installed and loaded at the same time your package is installed and loaded. Additionally, there is a practice of using package::function within the R files to be even more clear about what functions belong to what packages. 


Use appropriate spacing and indentation in your code so that is legible to outsiders. 


Comment, comment, comment! This is very important not only so others can understand your code but you can quickly refresh your memory after large gaps of not working on something. 

## Help files

An important aspect of R and RStudio is the help files for all existing R functions. After creating a function for your package, it may be useful to immediately create the help file to keep track of what the function should do it and how it operates. The help files are stored in the _*man/*_ directory and consist of text files with the `.Rd` extension. The 



# Export your functions


In the R file, you can add unique comments to tell your package how to write your help files and which functions to export.

This is all done through Roxygen



Use `devtools::document()` to comb through all files in _*R/*_ looking at the `roxygen2` comments and updating the `.Rd` help files and `NAMESPACE` file. All comments about the arguments and description will be added to the help files while the exports will be added to the NAMESPACE file. 


It is recommended to use this method to update the `NAMESPACE` file rather than writing that file automatically. It is unclear why. If your existing `NAMESPACE` file was not generated by `roxygen2`, then you can delete the file and run `devtools::document()` to generate a new one. 


It is still possible to update the help files in _*man/*_ manually. This is what I found to be easiest.



An important aspect of R and RStudio is the help files for all existing R functions. After creating a function for your package, it may be useful to immediately create the help file to keep track of what the function should do it and how it operates. The help files are stored in the `man/` directory and consist of text files with the `.Rd` extension. The 


# Including Data

usethis::use_data(x, mtcars)

# Exporting your functions

Use the #' export tag above all functions that you wish to export. This will include them in the package bundle and make them available for use. Functions not exported will be bundled as internal functions. Do this for functions you may use internally as assistants to you other functions that users should not interact with.


Once you have properly noted which functions you want to export, run `devtools::document()` to add these functions to the NAMESPACE file. This is the file that contains the list of all exported functions. It should not be written manually and should be updated by the code above. Removing already exported functions from the namespace is as simple as removing the tag and rerunning the code.

# Sources


# Other stuff


### The Dots Argument

In many R functions, an argument is included that resembles three dots as if to imply there is more to the function. The purpose of this argument is so that a user may supply other settings. For example, if your function calls upon other functions, you may use the dots argument to allow users to supply arguments to that function in your function.



### NEWS.md

This is the version history for the package. Each version submitted to CRAN should have a markdown heading with a bulleted list of changes.


### Testing

Most testing of software code is done informally during development. For example, you might write a function then load it into your environment and try it out to see that it works as you intended. The reason this is informal testing is because it is not automated. It is done ad-hoc and you might not remember the results or how you were testing. By creating more formal tests, you will have a system to repeatedly check your functions in the same way to ensure they work properly after multiple rounds of changes. 


Hadley's book gives a detailed description to test and resources to set it up in your package.





### Submit to cran

devtools::check() will perform an R CMD check which is necessary before submitting to CRAN. 


#### Versioning

*Major*.*Minor*.*Patch*

Major: big improvements/new features that change the usage of the software.

Minor: smaller improvements/new features that still alter the use of the software.

Patch: generally reserved for small fixes

Ex. 1.2.1

They work like ordered categories where say 0.0.1 < 0.1.0 < 1.0.0

For development, the convention of using .9000 at the end is a recognized numbering scheme in software development for denoting the version is in development. So, if you have something like 2.0.1.9000 then you know that this version is in development. After the development is complete and you need to pick a new version then you increase the 



I have been referencing the scheme utilized by the video game World of Warcraft (WoW) because they have followed the  versioning scheme and the uses for each case make sense. Major updates offer a great deal of content such as new regions or playable characters that greatly affect the game. Minor updates include new content within the regions such as a sub-region or new objectives. Patch generally addresses gameplay or character fixes. The full list of WoW versioning can be found at (https://wowpedia.fandom.com/wiki/Category:World_of_Warcraft_patches). 



# Appendix

## Appendix A - Git & GitHub



```{git}
git branch -m master <Branch>
git fetch origin
git branch -u origin/<Branch> <Branch>
git remote set-head origin -a
```




```{git}
git branch -m master main
git fetch origin
git branch -u origin/main main
git remote set-head origin -a
```
